/*  OpenDRT 
    -------------------------------------------------
      v0.1.3
      Written by Jed Smith
      https://github.com/jedypod/open-display-transform
*/

DEFINE_UI_PARAMS(in_gamut, input gamut, DCTLUI_COMBO_BOX, 1, {ap0, ap1, p3d65, rec2020, rec709, awg, rwg, sgamut3, blackmagicwg, egamut, davinciwg}, {ACES AP0, ACES AP1, P3D65, Rec.2020, Rec.709, Alexa Wide Gamut, Red Wide Gamut RGB, Sony SGamut3, Blackmagic Wide Gamut, Filmlight E - Gamut, DaVinci Wide Gamut})
DEFINE_UI_PARAMS(in_curve, input curve, DCTLUI_COMBO_BOX, 0, {linear, acescct, arri_logc, red_log3g10, sony_slog3, blackmagic_film_gen5, filmlight_tlog, davinci_intermediate}, {Linear, ACEScct, Arri V3LogC, Red Log3G10, Sony SLog3, Blackmagic Film Gen5, Filmlight TLog, DaVinci Intermediate})
DEFINE_UI_PARAMS(preset, preset, DCTLUI_COMBO_BOX, 0, {sdr_rec1886, sdr_srgb, sdr_applep3, sdr_rec2020, hdr_rec2020_pq_100nit, hdr_rec2020_pq_600nit, hdr_rec2020_pq_1000nit, hdr_rec2020_hlg_1000nit, hdr_rec2020_pq_2000nit, hdr_rec2020_pq_4000nit, hdr_p3d65_pq_100nit, hdr_p3d65_pq_600nit, hdr_p3d65_pq_1000nit, hdr_p3d65_pq_2000nit, hdr_p3d65_pq_4000nit, dci_p3d60, dci_p3d65, dci_p3dci, dci_dcdm}, {Rec.1886: 2.4 Power | Rec.709, sRGB Display: 2.2 Power | Rec.709, Apple Display P3: 2.2 Power | P3D65, Rec.2020: 2.4 Power | Rec.2020, Rec.2100: ST 2084 PQ | Rec.2020 | 100 nit, Rec.2100: ST 2084 PQ | Rec.2020 | 600 nit, Rec.2100: ST 2084 PQ | Rec.2020 | 1000 nit, Rec.2100: HLG | Rec.2020 | 1000 nit, Rec.2100: ST 2084 PQ | Rec.2020 | 2000 nit, Rec.2100: ST 2084 PQ | Rec.2020 | 4000 nit, Dolby: ST 2084 PQ | P3D65 | 100 nit, Dolby: ST 2084 PQ | P3D65 | 600 nit, Dolby: ST 2084 PQ | P3D65 | 1000 nit, Dolby: ST 2084 PQ | P3D65 | 2000 nit, Dolby: ST 2084 PQ | P3D65 | 4000 nit, DCI: 2.6 Power | P3 D60, DCI: 2.6 Power | P3 D65, DCI: 2.6 Power | P3 DCI, DCI: 2.6 Power | DCDM XYZ})
DEFINE_UI_PARAMS(wp, whitepoint, DCTLUI_COMBO_BOX, 3, {D50, D55, D60, D65, D75, D93}, {D50, D55, D60, D65, D75, D93})
DEFINE_UI_PARAMS(invert, invert, DCTLUI_CHECK_BOX, 0)

#include "libDRT.h"

// Whitepoint normalization factors for each possible output display gamut
__CONSTANT__ wpnorm wnd50 = {1.09063f, 1.1408f, 1.09928f, 1.2469f, 1.17646f, 1.0f};
__CONSTANT__ wpnorm wnd55 = {1.05337f, 1.08334f, 1.04391f, 1.18409f, 1.10416f, 1.0f};
__CONSTANT__ wpnorm wnd60 = {1.02355f, 1.037f, 1.00028f, 1.13345f, 1.0461f, 1.0f};
__CONSTANT__ wpnorm wnd65 = {1.0f, 1.0f, 1.08307f, 1.15054f, 1.0f, 1.0f};
__CONSTANT__ wpnorm wnd75 = {1.12915f, 1.13116f, 1.22512f, 1.30144f, 1.14486f, 1.0f};
__CONSTANT__ wpnorm wnd93 = {1.30631f, 1.31116f, 1.42007f, 1.50853f, 1.34374f, 1.0f};


__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{

  /* Parameters and Setup 
     ----------------------------------------------------------- */

  // Input gamut conversion to D65 aligned XYZ (CAT: xyz scaling)
  float3x3 in_to_xyz;
  if (in_gamut == ap0)                in_to_xyz = matrix_ap0_to_xyz;
  else if (in_gamut == ap1)           in_to_xyz = matrix_ap1_to_xyz;
  else if (in_gamut == p3d65)         in_to_xyz = matrix_p3d65_to_xyz;
  else if (in_gamut == rec2020)       in_to_xyz = matrix_rec2020_to_xyz;
  else if (in_gamut == rec709)        in_to_xyz = matrix_rec709_to_xyz;
  else if (in_gamut == awg)           in_to_xyz = matrix_arriwg_to_xyz;
  else if (in_gamut == rwg)           in_to_xyz = matrix_redwg_to_xyz;
  else if (in_gamut == sgamut3)       in_to_xyz = matrix_sonysgamut3;
  else if (in_gamut == blackmagicwg)  in_to_xyz = matrix_blackmagicwg_to_xyz;
  else if (in_gamut == egamut)        in_to_xyz = matrix_egamut_to_xyz;
  else if (in_gamut == davinciwg)     in_to_xyz = matrix_davinciwg_to_xyz;

  /*    Convert input colorspace into CIE 1931 XYZ with D65 whitepoint, 
        using XYZ Scaling as the chromatic adaptation method.
        We convert XYZ into Truelight LMS colorspace, then normalize 
        so that D65 white is equal energy. This is our reference point.
        After display rendering we scale to output whitepoint in LMS.
    */
      
  const float3x3 xyz_to_in = inv_f33(in_to_xyz);

  // Transfer function for linearizing input
  int tf;
  if (in_curve == linear)                     tf = 0;
  else if (in_curve == acescct)               tf = 1;
  else if (in_curve == arri_logc)             tf = 2;
  else if (in_curve == red_log3g10)           tf = 3;
  else if (in_curve == sony_slog3)            tf = 4;
  else if (in_curve == filmlight_tlog)        tf = 5;
  else if (in_curve == davinci_intermediate)  tf = 6;
  else if (in_curve == blackmagic_film_gen5)  tf = 7;

  /* Whitepoint handling */

  // CAT scale factor for creative output whitepoint
  float3 cats;

  // Normalization factor to scale display light, compensating for peak white shift
  // due to chromatic adaptation to target creative whitepoint.
  wpnorm wn;
  
  // Set up whitepoint based on user parameters
  if (wp == D50)         cats = catd50, wn = wnd50;
  else if (wp == D55)    cats = catd55, wn = wnd55;
  else if (wp == D60)    cats = catd60, wn = wnd60;
  else if (wp == D65)    cats = catd65, wn = wnd65;
  else if (wp == D75)    cats = catd75, wn = wnd75;
  else if (wp == D93)    cats = catd93, wn = wnd93;

  // forward and inverse Truelight LMS matrix
  const float3x3 xyz_to_tlms = matrix_xyz_to_truelightlms;
  const float3x3 tlms_to_xyz = inv_f33(matrix_xyz_to_truelightlms);
  

  // highlight dechroma 
  const float dch = 0.5f;

  /* Set up presets
     ----------------------- */
  int eotf;
  float Lp, su, w_n;
  float3x3 xyz_to_display;

  if (preset == sdr_rec1886) Lp = 100.0f, su = 0.95f, xyz_to_display = inv_f33(matrix_rec709_to_xyz), w_n = wn.rec709, eotf = 2;
  else if (preset == sdr_srgb) Lp = 100.0f, su = 0.9f, xyz_to_display = inv_f33(matrix_rec709_to_xyz), w_n = wn.rec709, eotf = 1;
  else if (preset == sdr_applep3) Lp = 100.0f, su = 0.9f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 1;
  else if (preset == sdr_rec2020) Lp = 100.0f, su = 0.95f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 2;
  else if (preset == dci_p3d60) Lp = 100.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d60_to_xyz), w_n = wn.p3d60, eotf = 3;
  else if (preset == dci_p3d65) Lp = 100.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 3;
  else if (preset == dci_p3dci) Lp = 100.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3dci_to_xyz), w_n = wn.p3dci, eotf = 3;
  else if (preset == dci_dcdm) Lp = 100.0f,  52.37f / 48.0f, su = 1.0f, xyz_to_display = identity_mtx, w_n = wn.dcdm, eotf = 3;
  else if (preset == hdr_rec2020_pq_100nit) Lp = 100.0f, su = 0.95f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 4;
  else if (preset == hdr_rec2020_pq_600nit) Lp = 600.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 4;
  else if (preset == hdr_rec2020_pq_1000nit) Lp = 1000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 4;
  else if (preset == hdr_rec2020_hlg_1000nit) Lp = 1000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 5;
  else if (preset == hdr_rec2020_pq_2000nit) Lp = 2000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 4;
  else if (preset == hdr_rec2020_pq_4000nit) Lp = 4000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_rec2020_to_xyz), w_n = wn.rec2020, eotf = 4;
  else if (preset == hdr_p3d65_pq_100nit) Lp = 100.0f, su = 0.95f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 4;
  else if (preset == hdr_p3d65_pq_600nit) Lp = 600.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 4;
  else if (preset == hdr_p3d65_pq_1000nit) Lp = 1000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 4;
  else if (preset == hdr_p3d65_pq_2000nit) Lp = 2000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 4;
  else if (preset == hdr_p3d65_pq_4000nit) Lp = 4000.0f, su = 1.0f, xyz_to_display = inv_f33(matrix_p3d65_to_xyz), w_n = wn.p3d65, eotf = 4;

  const float3x3 display_to_xyz = inv_f33(xyz_to_display);

  /* Tone Scale
      OpenDRT uses a 3-stage tonescale model. 
      - Stage 1 is a hyperbolic compression function based on the Michaelis-Menten equation. 
      - Stage 2 is a power function applied after the hyperbolic compression to adjust contrast.
      - Stage 3 is a parabolic toe compression function used for flare compensation.

      More details with math (see the "Michaelis-Menten Spring with Varying Power model")
      https://colab.research.google.com/drive/1aEjQDPlPveWPvhNoEfK4vGH5Tet8y1EB
      https://colab.research.google.com/drive/10C3HvDuoAhYad1qOG2r0v8fGR-5VdpO5

      This implementation is inspired by Daniele Siragusano's post:
      https://community.acescentral.com/t/output-transform-tone-scale/3498/14

      The parameter space are all const floats specified by user parameters.
      The constants are used in the rendering code to apply the tonescale.
  */
  
  
  // Calculate tonescale parameters
  const float sat = _fmaxf(1.0f, 1.125f - 0.00025f*Lp);
  
  // flare
  const float fl = 0.01f;
  
  // contrast
  const float c = 26.5f*_powf(Lp, -1.1f)+1.18f; // post-tonemap contrast
  const float p = c*su; // surround compensation, unconstrained
  
  // boost peak to clip : ~32@100nits, ~75~1000nits, ~100@4000nits
  const float w1 = _powf(0.44f*Lp/10000.0f, 0.8534f) + 1.033f;
  const float s1 = w1*Lp/100.0f; // scale y: 1@100nits, 40@4000nits

  // middle grey position / exposure: ~10nits at 100nits SDR, ~16.3nits at 4000nits HDR
  const float e0 = 0.0153f*_powf(Lp, 0.5224f) + 1.1656f;
  const float s0 = s1/e0;
  
  // Display scale: remap peak white depending on output inverse EOTF
  const float ds = eotf == 4 ? 0.01f : eotf == 5 ? 0.1f : preset == dci_dcdm ? 48.0f / 52.37f :100.0f/Lp;
  
  // Display maximum for display-linear clamp.
  const float clamp_max = preset == dci_dcdm ? 1.0f : ds*Lp/100.0f;
  

  // R G B weights for vector length norm. Affects luminance and chroma of output color.
  const float3 vw = make_float3(0.24f, 0.1f, 0.1f);

  // Normalization for weighted vector length norm so that achromatic values are not scaled
  const float vwn = _sqrtf(vw.x*vw.x + vw.y*vw.y + vw.z*vw.z);

  

  /* Forward Display Rendering 
     ----------------------------------------------------------- */

  float3 rgb = make_float3(p_R, p_G, p_B);


  if (invert == 0) {
    // Linearize input
    rgb = log2lin(rgb, tf);

    // Input gamut to xyz d65 cat: xyz scaling
    rgb = mult_f3_f33(rgb, in_to_xyz);

    // XYZ to Truelight LMS
    float3 lms = mult_f3_f33(rgb, xyz_to_tlms);

    // Normalize D65 white to equal energy
    lms /= catd65;

    // Weighted vector length norm
    lms = maxf3(1e-12f, lms);
    float n = _sqrtf(_powf(vw.x * lms.x, 2.0f) + _powf(vw.y * lms.y, 2.0f) + _powf(vw.z * lms.z, 2.0f)) / vwn;

    // RGB Ratios
    lms /= n;

    // Tonescale and flare compensation
    float ts = s1*_powf(n/(n + s0), p);
    ts = ts*ts/(ts + fl);

    // Chroma compression factor
    float ccf = _powf(s0/(n + s0), dch)*sat;
    
     // Compress chroma: chromaticity-linear desaturation by ccf (lerp towards 1.0 in rgb ratios)
    lms = (1.0f - ccf) + lms*ccf;

    // Display-referred LMS
    lms *= ts;
    
    // Apply output creative output whitepoint scale to both scene lms and display lms
    // Also normalize by w_n so that channels are not pushed above display peak luminance. 
    // For example if using a D55 whitepoint, without normalization the R channel would be > 1
    lms *= cats / w_n;
    
    // Convert from Truelight LMS to XYZ
    float3 xyz = mult_f3_f33(lms, tlms_to_xyz);

    // Convert XYZ to display gamut
    rgb = mult_f3_f33(xyz, xyz_to_display);

    // Scale for display device
    rgb *= ds;

    // Clamp
    rgb = clampf3(rgb, 0.0f, clamp_max);

    // Inverse EOTF
    float eotf_p = 2.0f + eotf * 0.2f; 
    if ((eotf > 0) && (eotf < 4)) { // Power Function
      rgb = powf3(rgb, 1.0f / eotf_p);
    } else if (eotf == 4) { // ST2084 PQ
      rgb = eotf_pq(rgb, 1, 0);
    } else if (eotf == 5) { // HLG
      rgb = eotf_hlg(rgb, 1);
    }
  } else {
    
    /* Inverse Display Rendering
       -------------------------
        Inverse will not be an exact match, due to multiple factors:
        - Limitations of display gamut volume
        - Mis-matches in more saturated colors due to weighted vector length norm
    */
    
    rgb = clampf3(rgb, 0.0f, 1.0f);

    // Forward EOTF
    float eotf_p = 2.0f + eotf * 0.2f;
    if ((eotf > 0) && (eotf < 4)) { // Power Function
      rgb = powf3(rgb, eotf_p);
    } else if (eotf == 4) { // ST2084 PQ
      rgb = eotf_pq(rgb, 0, 0);
    } else if (eotf == 5) { // HLG
      rgb = eotf_hlg(rgb, 0);
    }


    // Inverse output scale
    rgb /= ds;

    // display gamut to XYZ
    rgb = maxf3(0.0f, rgb);
    float3 xyz = mult_f3_f33(rgb, display_to_xyz);

    // XYZ to LMS
    float3 lms = mult_f3_f33(xyz, xyz_to_tlms);

    // Inverse output creative output whitepoint scale
    lms /= cats;

    // Weighted vector length norm
    float n = _sqrtf(_powf(vw.x * lms.x, 2.0f) + _powf(vw.y * lms.y, 2.0f) + _powf(vw.z * lms.z, 2.0f)) / vwn;

    // RGB Ratios
    lms /= n;

    // Inverse tone scale 
    float ts = (n + _sqrtf(n*(4.0f*fl + n)))/2.0f;
    ts = s0/(_powf(s1/ts, 1.0f/p) - 1.0f);
    
    // Chroma compression factor
    float ccf = _powf(s0 / (ts + s0), dch) * sat;

    // Inverse chroma compression
    lms = ((ccf - 1.0f) + lms)/ccf;

    // Scene-referred LMS
    lms *= ts;

    // Inverse D65 Normalization
    lms *= catd65;

    // LMS to XYZ
    xyz = mult_f3_f33(lms, tlms_to_xyz);

    // XYZ to input gamut.
    rgb = mult_f3_f33(xyz, xyz_to_in);
    
    // Return to working space
    rgb = lin2log(rgb, tf);
  }

  return rgb;
}